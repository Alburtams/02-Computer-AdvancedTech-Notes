# 资源调度

一切的软件系统都是构建在硬件服务器的基础上，从最开始的物理机直接部署软件系统，到虚拟机的应用，最后到资源上云容器化，硬件资源的使用也开始了集约化的管理。本节对比的是传统运维角色对应的职责范围，在 devops 环境下，开发运维一体化，也即资源的灵活高效使用。

#### 弹性伸缩

过去软件系统随着用户量增长须要增长机器资源的话，传统的方式就是找运维申请机器，而后部署好软件服务接入集群，整个过程依赖的是运维人员的人肉经验，效率低下并且容易出错。微服务分布式则无需人肉增长物理机器，在容器化技术的支撑下，只须要申请云资源，而后执行容器脚本便可。

- 应用扩容：用户激增须要对服务进行扩展，包括自动化扩容，峰值事后的自动缩容
- 机器下线：对于过期应用，进行应用下线，云平台收回容器宿主资源
- 机器置换：对于故障机器，可供置换容器宿主资源，服务自动启动，无缝切换

# 自动化运维

从资源申请管理的时候就介绍到 devops 的趋势，真正作到开发运维一体化则须要不一样的中间件来配合完成。

#### 配置中心

全局配置中心按环境来区分，统一管理，减小了多处配置的混乱局面。

- switch
- diamend

#### 部署策略

微服务分布式部署是屡见不鲜，如何让服务更好地支撑业务发展，稳健的部署策略是首先须要考虑的，以下的部署策略适合不一样业务和不一样的阶段。

- 停机部署
- 滚动部署
- 蓝绿部署
- 灰度部署
- A/B 测试

#### 做业调度

任务调度是系统必不可少的一个环节，传统的方式是在 Linux 机器上配置 crond 定时任务或者直接在业务代码里面完成调度业务，如今则是成熟的中间件来代替。

- SchedulerX
- Spring 定时任务

#### 应用管理

运维工做中很大一部分时间须要对应用进行重启，上下线操做，还有日志清理。

- 应用重启
- 应用下线
- 日志清理

# 网络管理

有了计算资源后，另外最重要的就是网络资源。现有的云化背景下，几乎不会直接接触到物理的带宽资源，而是直接由云平台统一管理带宽资源。因此需要对网络资源的最大化应用和有效的管理。

- 域名申请：应用申请配套域名资源的申请，多套域名映射规则的规范
- 域名变动：域名变动统一平台管理
- 负载管理：多机应用的访问策略设定
- 安全外联：基础访问鉴权，拦截非法请求
- 统一接入：提供统一接入的权限申请平台，提供统一的登陆管理

#### 故障快照

在系统故障的时候第一要务是系统恢复，同时保留案发现场也是很是重要的，资源调度平台则须要有统一的机制保存好故障现场。

- 现场保留：内存分布，线程数等资源现象的保存，如 JavaDump 钩子接入
- 调试接入：采用字节码技术无需侵入业务代码，能够供生产环境现场日志打点调试

# 流量调度

建设好分布式系统后，最早受到考验的关口就是网关了，进而须要关注系统流量的状况，也就是如何对流量的管理。分布式系统追求的是在系统可容纳的流量上限内，把资源留给最优质的流量使用、把非法恶意的流量挡在门外，这样节省成本的同时确保系统不会被冲击崩溃。

#### 负载均衡

负载均衡是对服务如何消化流量的通用设计，一般分为物理层的底层协议分流的硬负载均衡和软件层的软负载。负载均衡解决方案已是业界成熟的方案，一般会针对特定业务在不一样环境进行优化，经常使用有以下的负载均衡解决方案：

- 交换机
- F5
- LVS/ALI-LVS
- Nginx/Tengine
- VIPServer/ConfigServer

#### 网关设计

负载均衡首当其冲的就是网关，由于中心化集群流量最早打到的地方就是网关了，若是网关扛不住压力的话，那么整个系统将不可用。

- 高性能：网关设计第一须要考虑的是高性能的流量转发，网关单节点一般能达到上百万的并发流量
- 分布式：出于流量压力分担和灾备考虑，网关设计一样须要分布式
- 业务筛选：网关同设计简单的规则，排除掉大部分的恶意流量

#### 流量管理

- 请求校验：请求鉴权能够把多少非法请求拦截，清洗
- 数据缓存：多数无状态的请求存在数据热点，因此采用 CDN 能够把至关大一部分的流量消费掉

#### 流控控制

剩下的真实流量，采用不一样的算法来分流请求。

- 流量分配
  - 计数器
  - 队列
  - 漏斗
  - 令牌桶
  - 动态流控
- 流量限制在流量激增的时候，一般须要有限流措施来防止系统出现雪崩，那么就须要预估系统的流量上限，而后设定好上限数，但流量增长到必定阈值后，多出来的流量则不会进入系统，经过牺牲部分流量来保全系统的可用性。
  - 限流策略
  - QPS 粒度
  - 线程数粒度
  - RT 阈值
  - 限流工具 - Sentinel

# 服务调度

所谓打铁还需自身硬，流量作好了调度管理后，剩下的就是服务自身的健壮性了。分布式系统服务出现故障是常有的事情，所以须要把故障预防当作是分布式服务的一部分。

#### 注册中心

网关是流量的集散地，而注册中心则是服务的根据地。

- 状态类型：第一好应用服务的状态，经过注册中心就能够检测服务是否可用
- 生命周期：应用服务不一样的状态组成了应用的生命周期

#### 版本管理

- 集群版本：集群不用应用有自身对应的版本号，由不一样服务组成的集群也须要定义大的版本号
- 版本回滚：在部署异常的时候能够根据大的集群版本进行回滚管理

#### 服务编排

服务编排的定义是：经过消息的交互序列来控制各个部分资源的交互。参与交互的资源都是对等的，没有集中的控制。微服务环境下服务众多，须要有一个总的协调器来协议服务之间的依赖，调用关系，K8s 则是服务编排的不二选择。

- K8s
- Spring Cloud
  - HSF
  - ZK+Dubbo

#### 服务控制

前面解决了网络的健壮性和效率问题，这节介绍的是如何使服务更加健壮。

- 发现资源管理那节介绍了从云平台申请了容器宿主资源后，经过自动化脚本就能够启动应用服务，启动后服务则须要发现注册中心，而且把自身的服务信息注册到服务网关，便是网关接入。注册中心则会监控服务的不一样状态，作健康检查，把不可用的服务归类标记。
  - 网关接入
  - 健康检查
- 降级：当用户激增的时候，需要首先是在流量端作手脚，也就是限流。当发现限流后系统响应变慢了，有可能致使更多的问题时，也须要对服务自己作一些操做。服务降级就是把当前不是很核心的功能关闭掉，或者不是很要紧的准确性放宽范围，过后再作一些人工补救。
  - 下降一致性约束
  - 关闭非核心服务
  - 简化功能
- 熔断：当都作了以上的操做后，仍是以为不放心，那么就须要再进一步操心。熔断是对过载的一种自身保护，犹如咱们开关跳闸同样。好比当服务不断对数据库进行查询的时候，若是业务问题形成查询问题，这是数据库自己须要熔断来保证不会被应用拖垮，而且访问友好的信息，告诉服务不要再盲目调用了。
  - 闭合状态
  - 半开状态
  - 断开状态
  - 熔断工具- Hystrix
- 幂等：一个幂等操做的特色是其任意屡次执行所产生的影响均与一次执行的影响相同。那么就须要对单次操做赋予一个全局的 id 来作标识，这样屡次请求后咱们能够判断来源于同个客户端，避免出现脏数据。
  - 全局一致性 ID
  - Snowflake

# 数据调度

数据存储最大的挑战就是数据冗余的管理，冗余多了效率变低并且占用资源，副本少了起不到灾备的做用，一般的作法是把有转态的请求，经过转态分离，转化为无状态请求。

#### 状态转移

分离状态至全局存储，请求转换为无状态流量，好比咱们一般会将登录信息缓存至全局 redis 中间件，而不须要在多个应用中去冗余用户的登录数据。

#### 分库分表

数据横向扩展。

#### 分片分区

多副本冗余。

# 性能调优

参考[《高并发编程知识体系》](https://www.atatech.org/articles/122391)

#### 高并发

多线程编程模式提高了系统的吞吐量，但也同时带来了业务的复杂度。

#### 异步

事件驱动的异步编程是一种新的编程模式，摒弃了多线程的复杂业务处理问题，同时可以提高系统的响应效率。

- 业务异步化（线程池 / 消息队列）
- 底层异步化（网络IO）

#### 分布式锁

缓存是解决性能问题的一大利器，理想状况下，每一个请求不须要额外计算就马上能获取到结果时最快。小到 CPU 的三级缓存，大到分布式缓存，缓存无处不在，分布式缓存须要解决的就是数据的一致性，这个时候引入了分布式锁的概念，如何处理分布式锁的问题将决定咱们获取缓存数据的效率。

# 全栈监控

因为分布式系统是由众多机器共同协做的系统，并且网络也没法保证彻底可用，因此须要建设一套对各个环节都能监控的系统，这样才能从底层到业务各个层面进行监控，出现意外的时候能够及时修复故障，避免更多的问题出现。

#### 基础层

基础层面是对容器资源的监测，包含各个硬件指标的负载状况

- CPU、IO、内存、线程、吞吐

#### 中间件

分布式系统接入了大量的中间件平台，中间件自己的健康状况也须要监控。

#### 应用层

- 性能监控：应用层面的须要对每一个应用服务的实时指标（qps，rt），上下游依赖等进行监控
- 业务监控：除了应用自己的监控程度，业务监控也是保证系统正常的一个环节，经过设计合理的业务规则，对异常的状况作报警设置

#### 监控链路

- zipkin/eagleeye
- sls
- goc
- Alimonitor

# 容错处理

分布式系统故障是屡见不鲜，那么应对故障的方案也是不可或缺的环节。一般有主动和被动的方式来处理：

- 主动是在错误出现的时候，试图再试试几回，说不定就成功了，成功的话就能够避免了该次错误
- 被动方式是错误的事情已经发生了，为了挽回，只是作时候处理，把负面影响降到最小

#### 重试设计

重试设计的关键在于设计好重试的时间和次数，若是超太重试次数，或是一段时间，那么重试就没有意义了。开源的项目 spring-retry 能够很好地实现重试的计划。

#### 事务补偿

事务补偿符合最终一致性的理念。补偿事务不必定会将系统中的数据返回到原始操做开始时其所处的状态。 相反，它补偿操做失败前由已成功完成的步骤所执行的工做。补偿事务中步骤的顺序不必定与原始操做中步骤的顺序彻底相反。 例如，一个数据存储可能比另外一个数据存储对不一致性更加敏感，于是补偿事务中撤销对此存储的更改的步骤应该会首先发生。对完成操做所需的每一个资源采用短时间的基于超时的锁并预先获取这些资源，这样有助于增长整体活动成功的可能性。 仅在获取全部资源后才应执行工做。 锁过时以前必须完成全部操做。

# 故障恢复

当故障已经发生后，第一个要做的就是立刻消除故障，确保系统服务正常可用，这个时候一般作回滚操做。

#### 应用回滚

应用回滚以前须要保存好故障现场，以便排查缘由。

#### 基线回退

应用服务回滚后，代码基线也须要 revert 到前一版本。

#### 版本回滚

总体回滚须要服务编排，经过大版本号对集群进行回滚。

# 总结

最后总结一下，若是有可能的话，请尝试使用单节点方式而不是分布式系统。分布式系统伴随着一些失败的操做，为了处理灾难性故障，咱们使用备份；为了提升可靠性，咱们引入了冗余。

分布式系统本质就是一堆机器的协同，而咱们要作的就是搞出各类手段来然机器的运行达到预期。这么复杂的系统，须要了解各个环节、各个中间件的接入，是一个很是大的工程。庆幸的是，在微服务背景下，多数基础性的工做已经有人帮咱们实现了。前文所描述的分布式架构，在工程实现了是须要用到分布式三件套 (Docker+K8S+Srping Cloud) 基本就能够构建出来了。

分布式架构核心技术分布图以下：

![pic_006](https://resource.shangmayuan.com/droxy-blog/2019/11/05/526488bbaf3049d08f64aba3bda2bf9d-1.jpg)

