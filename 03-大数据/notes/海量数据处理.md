<!-- GFM-TOC -->

- [一、海量数据处理](#一海量数据处理)

- [二、 算法/数据结构基础](#二 算法/数据结构基础)

   <!-- GFM-TOC -->

# **一、海量数据处理**

所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，**就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。**

##### **那解决办法呢?**

针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/trie树。

针对空间，无非就一个办法：大而化小，分而治之（hash映射）。

# **二、算法/数据结构基础**

## **1.Bloom Filter**

Bloom Filter（BF）是一种空间效率很高的随机数据结构，**它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。**它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能**会出现错误判断，但不会漏掉判断。**也就是Bloom Filter**判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。**因此，Bloom Filter不适合那些“零错误”的应用场合。

而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。

##### **适用范围**

可以用来实现数据字典，进行数据的判重，或者集合求交集

具体参考：[海量数据处理之Bloom Filter详解](https://link.jianshu.com/?t=http://blog.csdn.net/v_july_v/article/details/6685894)

## **2.Hash**

Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是**把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。**这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

具体参考：[十一、从头到尾解析Hash表算法](https://link.jianshu.com/?t=http://blog.csdn.net/v_july_v/article/details/6256463)

## **3. Bit-map**

所谓的Bit-map就是用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。

如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：)

然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0x01<<(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）：

然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：

具体参考：[数据结构：位图法](https://link.jianshu.com/?t=http://blog.csdn.net/wypblog/article/details/8237956)

## **4.堆**

堆是一种特殊的二叉树，具备以下两种性质

1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值

2）树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。

如下图用一个数组来表示堆：

## **5.trie树**

下面我们有and,as,at,cn,com这些关键词，那么如何构建trie树呢？

从上面的图中，我们或多或少的可以发现一些好玩的特性。

第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。

第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。

第三：每个单词的公共前缀作为一个字符节点保存。

**适用范围：**

前缀统计，词频统计。

具体参考：[6天通吃树结构—— 第五天 Trie树](https://link.jianshu.com/?t=http://www.cnblogs.com/huangxincheng/archive/2012/11/25/2788268.html)

## **6.外排序**

**适用范围：**

大数据的排序，去重

** 基本原理及要点：**

外部排序的两个独立阶段：

1）首先按内存大小，将外存上含n个记录的文件分成若干长度L的子文件或段。依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。

2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为之。

外排序的优化方法：置换选择 败者树原理，最优归并树

具体参考：[选择置换+败者树搞定外部排序](https://link.jianshu.com/?t=http://www.cnblogs.com/benjamin-t/p/3325401.html)